# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.9
#
# <auto-generated>
#
# Generated from file `iot.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module IoT
_M_IoT = Ice.openModule('IoT')
__name__ = 'IoT'

if 'UnrecognisedSettingException' not in _M_IoT.__dict__:
    _M_IoT.UnrecognisedSettingException = Ice.createTempClass()
    class UnrecognisedSettingException(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IoT::UnrecognisedSettingException'

    _M_IoT._t_UnrecognisedSettingException = IcePy.defineException('::IoT::UnrecognisedSettingException', UnrecognisedSettingException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    UnrecognisedSettingException._ice_type = _M_IoT._t_UnrecognisedSettingException

    _M_IoT.UnrecognisedSettingException = UnrecognisedSettingException
    del UnrecognisedSettingException

if 'IllegalSettingValueException' not in _M_IoT.__dict__:
    _M_IoT.IllegalSettingValueException = Ice.createTempClass()
    class IllegalSettingValueException(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IoT::IllegalSettingValueException'

    _M_IoT._t_IllegalSettingValueException = IcePy.defineException('::IoT::IllegalSettingValueException', IllegalSettingValueException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    IllegalSettingValueException._ice_type = _M_IoT._t_IllegalSettingValueException

    _M_IoT.IllegalSettingValueException = IllegalSettingValueException
    del IllegalSettingValueException

if '_t_DeviceInfo' not in _M_IoT.__dict__:
    _M_IoT._t_DeviceInfo = IcePy.defineDictionary('::IoT::DeviceInfo', (), IcePy._t_string, IcePy._t_string)

if '_t_Settings' not in _M_IoT.__dict__:
    _M_IoT._t_Settings = IcePy.defineDictionary('::IoT::Settings', (), IcePy._t_string, IcePy._t_short)

if 'IoTDevice' not in _M_IoT.__dict__:
    _M_IoT.IoTDevice = Ice.createTempClass()
    class IoTDevice(Ice.Value):
        def __init__(self, name='', brand='', model='', type=''):
            self.name = name
            self.brand = brand
            self.model = model
            self.type = type

        def ice_id(self):
            return '::IoT::IoTDevice'

        @staticmethod
        def ice_staticId():
            return '::IoT::IoTDevice'

        def __str__(self):
            return IcePy.stringify(self, _M_IoT._t_IoTDevice)

        __repr__ = __str__

    _M_IoT._t_IoTDevice = IcePy.defineValue('::IoT::IoTDevice', IoTDevice, -1, (), False, False, None, (
        ('name', (), IcePy._t_string, False, 0),
        ('brand', (), IcePy._t_string, False, 0),
        ('model', (), IcePy._t_string, False, 0),
        ('type', (), IcePy._t_string, False, 0)
    ))
    IoTDevice._ice_type = _M_IoT._t_IoTDevice

    _M_IoT.IoTDevice = IoTDevice
    del IoTDevice

_M_IoT._t_IoTDeviceOperation = IcePy.defineValue('::IoT::IoTDeviceOperation', Ice.Value, -1, (), False, True, None, ())

if 'IoTDeviceOperationPrx' not in _M_IoT.__dict__:
    _M_IoT.IoTDeviceOperationPrx = Ice.createTempClass()
    class IoTDeviceOperationPrx(Ice.ObjectPrx):

        def getInfo(self, context=None):
            return _M_IoT.IoTDeviceOperation._op_getInfo.invoke(self, ((), context))

        def getInfoAsync(self, context=None):
            return _M_IoT.IoTDeviceOperation._op_getInfo.invokeAsync(self, ((), context))

        def begin_getInfo(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IoT.IoTDeviceOperation._op_getInfo.begin(self, ((), _response, _ex, _sent, context))

        def end_getInfo(self, _r):
            return _M_IoT.IoTDeviceOperation._op_getInfo.end(self, _r)

        def changeName(self, name, context=None):
            return _M_IoT.IoTDeviceOperation._op_changeName.invoke(self, ((name, ), context))

        def changeNameAsync(self, name, context=None):
            return _M_IoT.IoTDeviceOperation._op_changeName.invokeAsync(self, ((name, ), context))

        def begin_changeName(self, name, _response=None, _ex=None, _sent=None, context=None):
            return _M_IoT.IoTDeviceOperation._op_changeName.begin(self, ((name, ), _response, _ex, _sent, context))

        def end_changeName(self, _r):
            return _M_IoT.IoTDeviceOperation._op_changeName.end(self, _r)

        def changeSettings(self, settings, context=None):
            return _M_IoT.IoTDeviceOperation._op_changeSettings.invoke(self, ((settings, ), context))

        def changeSettingsAsync(self, settings, context=None):
            return _M_IoT.IoTDeviceOperation._op_changeSettings.invokeAsync(self, ((settings, ), context))

        def begin_changeSettings(self, settings, _response=None, _ex=None, _sent=None, context=None):
            return _M_IoT.IoTDeviceOperation._op_changeSettings.begin(self, ((settings, ), _response, _ex, _sent, context))

        def end_changeSettings(self, _r):
            return _M_IoT.IoTDeviceOperation._op_changeSettings.end(self, _r)

        def returnToFactorySettings(self, context=None):
            return _M_IoT.IoTDeviceOperation._op_returnToFactorySettings.invoke(self, ((), context))

        def returnToFactorySettingsAsync(self, context=None):
            return _M_IoT.IoTDeviceOperation._op_returnToFactorySettings.invokeAsync(self, ((), context))

        def begin_returnToFactorySettings(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IoT.IoTDeviceOperation._op_returnToFactorySettings.begin(self, ((), _response, _ex, _sent, context))

        def end_returnToFactorySettings(self, _r):
            return _M_IoT.IoTDeviceOperation._op_returnToFactorySettings.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IoT.IoTDeviceOperationPrx.ice_checkedCast(proxy, '::IoT::IoTDeviceOperation', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IoT.IoTDeviceOperationPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IoT::IoTDeviceOperation'
    _M_IoT._t_IoTDeviceOperationPrx = IcePy.defineProxy('::IoT::IoTDeviceOperation', IoTDeviceOperationPrx)

    _M_IoT.IoTDeviceOperationPrx = IoTDeviceOperationPrx
    del IoTDeviceOperationPrx

    _M_IoT.IoTDeviceOperation = Ice.createTempClass()
    class IoTDeviceOperation(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IoT::IoTDeviceOperation')

        def ice_id(self, current=None):
            return '::IoT::IoTDeviceOperation'

        @staticmethod
        def ice_staticId():
            return '::IoT::IoTDeviceOperation'

        def getInfo(self, current=None):
            raise NotImplementedError("servant method 'getInfo' not implemented")

        def changeName(self, name, current=None):
            raise NotImplementedError("servant method 'changeName' not implemented")

        def changeSettings(self, settings, current=None):
            raise NotImplementedError("servant method 'changeSettings' not implemented")

        def returnToFactorySettings(self, current=None):
            raise NotImplementedError("servant method 'returnToFactorySettings' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IoT._t_IoTDeviceOperationDisp)

        __repr__ = __str__

    _M_IoT._t_IoTDeviceOperationDisp = IcePy.defineClass('::IoT::IoTDeviceOperation', IoTDeviceOperation, (), None, ())
    IoTDeviceOperation._ice_type = _M_IoT._t_IoTDeviceOperationDisp

    IoTDeviceOperation._op_getInfo = IcePy.Operation('getInfo', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_IoT._t_DeviceInfo, False, 0), ())
    IoTDeviceOperation._op_changeName = IcePy.Operation('changeName', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), None, ())
    IoTDeviceOperation._op_changeSettings = IcePy.Operation('changeSettings', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IoT._t_Settings, False, 0),), (), None, (_M_IoT._t_UnrecognisedSettingException, _M_IoT._t_IllegalSettingValueException))
    IoTDeviceOperation._op_returnToFactorySettings = IcePy.Operation('returnToFactorySettings', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_IoT.IoTDeviceOperation = IoTDeviceOperation
    del IoTDeviceOperation

if 'BeverageType' not in _M_IoT.__dict__:
    _M_IoT.BeverageType = Ice.createTempClass()
    class BeverageType(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    BeverageType.AMERICANO = BeverageType("AMERICANO", 0)
    BeverageType.CAPPUCCINO = BeverageType("CAPPUCCINO", 1)
    BeverageType.ESPRESSO = BeverageType("ESPRESSO", 2)
    BeverageType.CARAMELMACCHIATO = BeverageType("CARAMELMACCHIATO", 3)
    BeverageType.TEA = BeverageType("TEA", 4)
    BeverageType.HOTCHOCOLATE = BeverageType("HOTCHOCOLATE", 5)
    BeverageType.HOTMILK = BeverageType("HOTMILK", 6)
    BeverageType._enumerators = { 0:BeverageType.AMERICANO, 1:BeverageType.CAPPUCCINO, 2:BeverageType.ESPRESSO, 3:BeverageType.CARAMELMACCHIATO, 4:BeverageType.TEA, 5:BeverageType.HOTCHOCOLATE, 6:BeverageType.HOTMILK }

    _M_IoT._t_BeverageType = IcePy.defineEnum('::IoT::BeverageType', BeverageType, (), BeverageType._enumerators)

    _M_IoT.BeverageType = BeverageType
    del BeverageType

if '_t_AvailableBeverageTypes' not in _M_IoT.__dict__:
    _M_IoT._t_AvailableBeverageTypes = IcePy.defineSequence('::IoT::AvailableBeverageTypes', (), _M_IoT._t_BeverageType)

if 'UnsupportedBeverageTypeException' not in _M_IoT.__dict__:
    _M_IoT.UnsupportedBeverageTypeException = Ice.createTempClass()
    class UnsupportedBeverageTypeException(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IoT::UnsupportedBeverageTypeException'

    _M_IoT._t_UnsupportedBeverageTypeException = IcePy.defineException('::IoT::UnsupportedBeverageTypeException', UnsupportedBeverageTypeException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    UnsupportedBeverageTypeException._ice_type = _M_IoT._t_UnsupportedBeverageTypeException

    _M_IoT.UnsupportedBeverageTypeException = UnsupportedBeverageTypeException
    del UnsupportedBeverageTypeException

if 'Ingredient' not in _M_IoT.__dict__:
    _M_IoT.Ingredient = Ice.createTempClass()
    class Ingredient(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Ingredient.COFFEEBEANS = Ingredient("COFFEEBEANS", 0)
    Ingredient.COFFEECAPSULES = Ingredient("COFFEECAPSULES", 1)
    Ingredient.CARAMELMACCHIATOCAPSULES = Ingredient("CARAMELMACCHIATOCAPSULES", 2)
    Ingredient.TEACAPSULES = Ingredient("TEACAPSULES", 3)
    Ingredient.CHOCOLATECAPSULES = Ingredient("CHOCOLATECAPSULES", 4)
    Ingredient.MILK = Ingredient("MILK", 5)
    Ingredient._enumerators = { 0:Ingredient.COFFEEBEANS, 1:Ingredient.COFFEECAPSULES, 2:Ingredient.CARAMELMACCHIATOCAPSULES, 3:Ingredient.TEACAPSULES, 4:Ingredient.CHOCOLATECAPSULES, 5:Ingredient.MILK }

    _M_IoT._t_Ingredient = IcePy.defineEnum('::IoT::Ingredient', Ingredient, (), Ingredient._enumerators)

    _M_IoT.Ingredient = Ingredient
    del Ingredient

if '_t_IngredientsQuantity' not in _M_IoT.__dict__:
    _M_IoT._t_IngredientsQuantity = IcePy.defineDictionary('::IoT::IngredientsQuantity', (), _M_IoT._t_Ingredient, IcePy._t_short)

if '_t_RequiredIngredientsQuantity' not in _M_IoT.__dict__:
    _M_IoT._t_RequiredIngredientsQuantity = IcePy.defineDictionary('::IoT::RequiredIngredientsQuantity', (), _M_IoT._t_BeverageType, _M_IoT._t_IngredientsQuantity)

if 'NotEnoughIngredientsException' not in _M_IoT.__dict__:
    _M_IoT.NotEnoughIngredientsException = Ice.createTempClass()
    class NotEnoughIngredientsException(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IoT::NotEnoughIngredientsException'

    _M_IoT._t_NotEnoughIngredientsException = IcePy.defineException('::IoT::NotEnoughIngredientsException', NotEnoughIngredientsException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    NotEnoughIngredientsException._ice_type = _M_IoT._t_NotEnoughIngredientsException

    _M_IoT.NotEnoughIngredientsException = NotEnoughIngredientsException
    del NotEnoughIngredientsException

if 'IllegalIngredientQuantityException' not in _M_IoT.__dict__:
    _M_IoT.IllegalIngredientQuantityException = Ice.createTempClass()
    class IllegalIngredientQuantityException(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IoT::IllegalIngredientQuantityException'

    _M_IoT._t_IllegalIngredientQuantityException = IcePy.defineException('::IoT::IllegalIngredientQuantityException', IllegalIngredientQuantityException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    IllegalIngredientQuantityException._ice_type = _M_IoT._t_IllegalIngredientQuantityException

    _M_IoT.IllegalIngredientQuantityException = IllegalIngredientQuantityException
    del IllegalIngredientQuantityException

if 'IllegalIngredientException' not in _M_IoT.__dict__:
    _M_IoT.IllegalIngredientException = Ice.createTempClass()
    class IllegalIngredientException(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IoT::IllegalIngredientException'

    _M_IoT._t_IllegalIngredientException = IcePy.defineException('::IoT::IllegalIngredientException', IllegalIngredientException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    IllegalIngredientException._ice_type = _M_IoT._t_IllegalIngredientException

    _M_IoT.IllegalIngredientException = IllegalIngredientException
    del IllegalIngredientException

if 'Beverage' not in _M_IoT.__dict__:
    _M_IoT.Beverage = Ice.createTempClass()
    class Beverage(object):
        def __init__(self, beverageType=_M_IoT.BeverageType.AMERICANO, volume=0):
            self.beverageType = beverageType
            self.volume = volume

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.beverageType)
            _h = 5 * _h + Ice.getHash(self.volume)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_IoT.Beverage):
                return NotImplemented
            else:
                if self.beverageType is None or other.beverageType is None:
                    if self.beverageType != other.beverageType:
                        return (-1 if self.beverageType is None else 1)
                else:
                    if self.beverageType < other.beverageType:
                        return -1
                    elif self.beverageType > other.beverageType:
                        return 1
                if self.volume is None or other.volume is None:
                    if self.volume != other.volume:
                        return (-1 if self.volume is None else 1)
                else:
                    if self.volume < other.volume:
                        return -1
                    elif self.volume > other.volume:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_IoT._t_Beverage)

        __repr__ = __str__

    _M_IoT._t_Beverage = IcePy.defineStruct('::IoT::Beverage', Beverage, (), (
        ('beverageType', (), _M_IoT._t_BeverageType),
        ('volume', (), IcePy._t_short)
    ))

    _M_IoT.Beverage = Beverage
    del Beverage

if 'CoffeeMaker' not in _M_IoT.__dict__:
    _M_IoT.CoffeeMaker = Ice.createTempClass()
    class CoffeeMaker(_M_IoT.IoTDevice):
        def __init__(self, name='', brand='', model='', type='', beverageTypes=None, ingredientsQuantity=None, maxIngredientsQuantity=None, requiredIngredientsQuantity=None, beveragesVolume=0, beveragesVolumeInitial=0):
            _M_IoT.IoTDevice.__init__(self, name, brand, model, type)
            self.beverageTypes = beverageTypes
            self.ingredientsQuantity = ingredientsQuantity
            self.maxIngredientsQuantity = maxIngredientsQuantity
            self.requiredIngredientsQuantity = requiredIngredientsQuantity
            self.beveragesVolume = beveragesVolume
            self.beveragesVolumeInitial = beveragesVolumeInitial

        def ice_id(self):
            return '::IoT::CoffeeMaker'

        @staticmethod
        def ice_staticId():
            return '::IoT::CoffeeMaker'

        def __str__(self):
            return IcePy.stringify(self, _M_IoT._t_CoffeeMaker)

        __repr__ = __str__

    _M_IoT._t_CoffeeMaker = IcePy.defineValue('::IoT::CoffeeMaker', CoffeeMaker, -1, (), False, False, _M_IoT._t_IoTDevice, (
        ('beverageTypes', (), _M_IoT._t_AvailableBeverageTypes, False, 0),
        ('ingredientsQuantity', (), _M_IoT._t_IngredientsQuantity, False, 0),
        ('maxIngredientsQuantity', (), _M_IoT._t_IngredientsQuantity, False, 0),
        ('requiredIngredientsQuantity', (), _M_IoT._t_RequiredIngredientsQuantity, False, 0),
        ('beveragesVolume', (), IcePy._t_short, False, 0),
        ('beveragesVolumeInitial', (), IcePy._t_short, False, 0)
    ))
    CoffeeMaker._ice_type = _M_IoT._t_CoffeeMaker

    _M_IoT.CoffeeMaker = CoffeeMaker
    del CoffeeMaker

_M_IoT._t_CoffeeMakerOperation = IcePy.defineValue('::IoT::CoffeeMakerOperation', Ice.Value, -1, (), False, True, None, ())

if 'CoffeeMakerOperationPrx' not in _M_IoT.__dict__:
    _M_IoT.CoffeeMakerOperationPrx = Ice.createTempClass()
    class CoffeeMakerOperationPrx(_M_IoT.IoTDeviceOperationPrx):

        def makeBeverage(self, beverageType, context=None):
            return _M_IoT.CoffeeMakerOperation._op_makeBeverage.invoke(self, ((beverageType, ), context))

        def makeBeverageAsync(self, beverageType, context=None):
            return _M_IoT.CoffeeMakerOperation._op_makeBeverage.invokeAsync(self, ((beverageType, ), context))

        def begin_makeBeverage(self, beverageType, _response=None, _ex=None, _sent=None, context=None):
            return _M_IoT.CoffeeMakerOperation._op_makeBeverage.begin(self, ((beverageType, ), _response, _ex, _sent, context))

        def end_makeBeverage(self, _r):
            return _M_IoT.CoffeeMakerOperation._op_makeBeverage.end(self, _r)

        def increaseIngredientQuantity(self, ingredient, quantity, context=None):
            return _M_IoT.CoffeeMakerOperation._op_increaseIngredientQuantity.invoke(self, ((ingredient, quantity), context))

        def increaseIngredientQuantityAsync(self, ingredient, quantity, context=None):
            return _M_IoT.CoffeeMakerOperation._op_increaseIngredientQuantity.invokeAsync(self, ((ingredient, quantity), context))

        def begin_increaseIngredientQuantity(self, ingredient, quantity, _response=None, _ex=None, _sent=None, context=None):
            return _M_IoT.CoffeeMakerOperation._op_increaseIngredientQuantity.begin(self, ((ingredient, quantity), _response, _ex, _sent, context))

        def end_increaseIngredientQuantity(self, _r):
            return _M_IoT.CoffeeMakerOperation._op_increaseIngredientQuantity.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IoT.CoffeeMakerOperationPrx.ice_checkedCast(proxy, '::IoT::CoffeeMakerOperation', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IoT.CoffeeMakerOperationPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IoT::CoffeeMakerOperation'
    _M_IoT._t_CoffeeMakerOperationPrx = IcePy.defineProxy('::IoT::CoffeeMakerOperation', CoffeeMakerOperationPrx)

    _M_IoT.CoffeeMakerOperationPrx = CoffeeMakerOperationPrx
    del CoffeeMakerOperationPrx

    _M_IoT.CoffeeMakerOperation = Ice.createTempClass()
    class CoffeeMakerOperation(_M_IoT.IoTDeviceOperation):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IoT::CoffeeMakerOperation', '::IoT::IoTDeviceOperation')

        def ice_id(self, current=None):
            return '::IoT::CoffeeMakerOperation'

        @staticmethod
        def ice_staticId():
            return '::IoT::CoffeeMakerOperation'

        def makeBeverage(self, beverageType, current=None):
            raise NotImplementedError("servant method 'makeBeverage' not implemented")

        def increaseIngredientQuantity(self, ingredient, quantity, current=None):
            raise NotImplementedError("servant method 'increaseIngredientQuantity' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IoT._t_CoffeeMakerOperationDisp)

        __repr__ = __str__

    _M_IoT._t_CoffeeMakerOperationDisp = IcePy.defineClass('::IoT::CoffeeMakerOperation', CoffeeMakerOperation, (), None, (_M_IoT._t_IoTDeviceOperationDisp,))
    CoffeeMakerOperation._ice_type = _M_IoT._t_CoffeeMakerOperationDisp

    CoffeeMakerOperation._op_makeBeverage = IcePy.Operation('makeBeverage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IoT._t_BeverageType, False, 0),), (), ((), _M_IoT._t_Beverage, False, 0), (_M_IoT._t_UnsupportedBeverageTypeException, _M_IoT._t_NotEnoughIngredientsException))
    CoffeeMakerOperation._op_increaseIngredientQuantity = IcePy.Operation('increaseIngredientQuantity', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IoT._t_Ingredient, False, 0), ((), IcePy._t_short, False, 0)), (), None, (_M_IoT._t_IllegalIngredientException, _M_IoT._t_IllegalIngredientQuantityException))

    _M_IoT.CoffeeMakerOperation = CoffeeMakerOperation
    del CoffeeMakerOperation

if 'Camera' not in _M_IoT.__dict__:
    _M_IoT.Camera = Ice.createTempClass()
    class Camera(_M_IoT.IoTDevice):
        def __init__(self, name='', brand='', model='', type='', pan=0, tilt=0, zoom=0):
            _M_IoT.IoTDevice.__init__(self, name, brand, model, type)
            self.pan = pan
            self.tilt = tilt
            self.zoom = zoom

        def ice_id(self):
            return '::IoT::Camera'

        @staticmethod
        def ice_staticId():
            return '::IoT::Camera'

        def __str__(self):
            return IcePy.stringify(self, _M_IoT._t_Camera)

        __repr__ = __str__

    _M_IoT._t_Camera = IcePy.defineValue('::IoT::Camera', Camera, -1, (), False, False, _M_IoT._t_IoTDevice, (
        ('pan', (), IcePy._t_short, False, 0),
        ('tilt', (), IcePy._t_short, False, 0),
        ('zoom', (), IcePy._t_short, False, 0)
    ))
    Camera._ice_type = _M_IoT._t_Camera

    _M_IoT.Camera = Camera
    del Camera

_M_IoT._t_CameraOperation = IcePy.defineValue('::IoT::CameraOperation', Ice.Value, -1, (), False, True, None, ())

if 'CameraOperationPrx' not in _M_IoT.__dict__:
    _M_IoT.CameraOperationPrx = Ice.createTempClass()
    class CameraOperationPrx(_M_IoT.IoTDeviceOperationPrx):

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IoT.CameraOperationPrx.ice_checkedCast(proxy, '::IoT::CameraOperation', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IoT.CameraOperationPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IoT::CameraOperation'
    _M_IoT._t_CameraOperationPrx = IcePy.defineProxy('::IoT::CameraOperation', CameraOperationPrx)

    _M_IoT.CameraOperationPrx = CameraOperationPrx
    del CameraOperationPrx

    _M_IoT.CameraOperation = Ice.createTempClass()
    class CameraOperation(_M_IoT.IoTDeviceOperation):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IoT::CameraOperation', '::IoT::IoTDeviceOperation')

        def ice_id(self, current=None):
            return '::IoT::CameraOperation'

        @staticmethod
        def ice_staticId():
            return '::IoT::CameraOperation'

        def __str__(self):
            return IcePy.stringify(self, _M_IoT._t_CameraOperationDisp)

        __repr__ = __str__

    _M_IoT._t_CameraOperationDisp = IcePy.defineClass('::IoT::CameraOperation', CameraOperation, (), None, (_M_IoT._t_IoTDeviceOperationDisp,))
    CameraOperation._ice_type = _M_IoT._t_CameraOperationDisp

    _M_IoT.CameraOperation = CameraOperation
    del CameraOperation

# End of module IoT
